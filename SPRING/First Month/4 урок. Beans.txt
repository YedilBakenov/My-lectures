Spring Beans являются основными компонентами, используемыми в Spring Framework для управления объектами.
В контексте Spring, bean — это самый обычный объект, который управляется Spring IoC (Inversion of Control) контейнером. 
IoC контейнер конфигурирует и управляет Spring beans во время выполнения приложения. 
Beans могут быть сконфигурированы через аннотации или Java конфигурацию. Они могут использоваться для любых объектов в вашем приложении,
например, для сервисов, репозиториев, контроллеров и других компонентов.

Application Context в Spring Framework - это интерфейс, который отвечает за создание бинов, конфигурацию, внедрение зависимостей,
а хранятся бины в IoC контейнере.
То есть, когда мы говорим об IoC контейнере в контексте Spring, мы часто имеем в виду именно Application Context. 


Spring IoC (Inversion of Control) контейнер — это одна из ключевых концепций Spring Framework,
обеспечивающая управление зависимостями между объектами. 
IoC контейнер упрощает разработку и тестирование, автоматически связывая компоненты приложения вместе.
Вместо того чтобы компоненты приложения самостоятельно создавали или искали свои зависимости, 
эти зависимости автоматически внедряются при создании объекта, что и является "инверсией контроля".
Управление жизненным циклом объектов (Bean): IoC контейнер создаёт и управляет всеми Spring beans, определёнными в вашем приложении.


Бин в Spring — это просто объект, который управляется Spring контейнером. Под "управлением" понимается создание объекта,
возможно внедрение в него других объектов (зависимостей), которые ему нужны для работы, и управление его жизненным циклом.
Когда вы аннотируете класс с @Component или другими подобными аннотациями (@Service, @Repository, @Controller), 
вы говорите Spring: "Эй, пожалуйста, создай объект этого класса для меня и позаботься о нем".


Существуют разновидности бинов:

1. @Component это общий случай. 
2. @Controller для классов, которые обрабатывают веб-запросы.
3. @Service для сервисных классов, которые выполняют бизнес-логику.
4. @Repository  для классов доступа к данным, которые работают с базой данных.


5. @Configuration
6. @Bean


1. Controller - Контроллеры обрабатывают входящие HTTP запросы через аннотированные методы. 
Для маршрутизации запросов к этим методам используются аннотации @RequestMapping или её специализированные версии (@GetMapping, @PostMapping и т.д.).

Внедрение зависимостей: В контроллеры могут быть внедрены необходимые зависимости, такие как сервисы или компоненты для доступа к данным, используя аннотацию @Autowired.


2. Service - реализует бизнес логику(все методы). Аннотация @Service используется для указания, что класс представляет собой сервис — компонент слоя бизнес-логики.
Все что мы пока прописываем в DBManager

3. Repository используется для указания на класс, который выполняет роль репозитория или DAO (Data Access Object).
Интеграция с JPA, Hibernate и другими ORM: @Repository часто используется в сочетании с JPA, Hibernate или JdbcTemplate для реализации операций доступа к данным.

4. Component - создается объект данного класса автоматически при старте приложения. До всех остальных бинов. @Component — это общий случай. все остальные его подтипы. 
Все что отличается от логики других бинов берет на себя Component.


Простыми словами о бине:
Если представить, что ваше приложение на Spring — это большой офис, то бин — это один из сотрудников. 
Spring — это менеджер, который нанимает сотрудников (создает объекты), определяет, кто с кем будет работать
(внедряет зависимости), и говорит, когда начинать и заканчивать работу (управляет жизненным циклом).

Отличия бинов:
@Component — это общий случай, когда вы хотите, чтобы Spring создал и управлял вашим объектом, но он не выполняет какую-то специфическую роль.
Это как нанять универсального сотрудника в офис, который может выполнять разные задачи.

@Service — используется для классов, которые выполняют сервисную или бизнес-логику.
Это как нанять сотрудника для работы в отделе услуг или поддержки, где он будет заниматься конкретными делами клиентов или бизнес-процессами.

@Repository — применяется к классам, которые работают непосредственно с базой данных. 
Это как нанять сотрудника для архива или бухгалтерии, где он будет отвечать за хранение и извлечение данных.

@Controller — используется в веб-приложениях для обработки HTTP запросов. Это как нанять фронт-менеджера,
который будет первым встречать клиентов (запросы) и направлять их к нужным сервисам или отделам внутри компании (приложения).
Выбирая между этими аннотациями, вы помогаете Spring понять, как лучше работать с вашими объектами,
а также делаете структуру приложения более понятной и организованной для других разработчиков.



В Spring Framework по умолчанию все бины создаются как синглтоны,
то есть для каждого бина в контексте приложения Spring создается только один экземпляр. 
Этот подход позволяет сократить количество необходимых ресурсов и упростить управление состоянием в приложении, 
поскольку синглтон-бины существуют в единственном экземпляре на протяжении всего жизненного цикла приложения.


Приступаем к коду:


1. Создаем папку и класс в корневой папке, который будет реализовывать логику нашей модели:

new -> service.FilmService

2. Добавляем аннотацию @Service

3. Создаем простой пример. В сервисах не используются статичные методы.
	
 показать пример с созданием объекта через констурктор внутри сервиса, что объект автоматичсеки создается,
до старта сервера томкат:

  public FilmService(){
        System.out.println("WE CREATED FILMSERVICE!");
    }

   public String getHello(){
        return "HELLO";
    } 	

4.  Инъекция (внедрение) зависимостей в Spring, по простому говоря когда один бин мы кладем в другой бин через аннотацию @Authorized. Устанавливаем связь между бинами. 
Добавляем в контроллер бин сервиса, чтобы мы могли использовать методы сервиса:

@Controller
public class HomeController {

    @Autowired
    private FilmService filmService;


и также добавляем в контроллер:
System.out.println(filmService.getHello());
перезапускаем проект

5. Используем получение всех фильмов уже через filmService

model.addAttribute("list", filmService.getFilms());

также создаем данный метод в FilmService

6. используем метод addFilm в filmService

 public void addFilm(Film film) {
        var films = getFilms();
        film.setId(id);
        id++;
        films.add(film);
    }

также меняем в контроллере

7. переделываем методы update и delete:


 public void updateFilm(Film film) {
        for(Film f: getFilms()){
            if(f.getId()==film.getId()){
                f.setTitle(film.getTitle());
                f.setDescription(film.getDescription());
                f.setRating(film.getRating());
            }
        }
    }

 public void deleteFilm(int id) {
        DBManager.deleteFilm(id);

    }

8. в сервисе создаем правильную конструкцию:

добавляем папку impl, а также создаем интерфейсе FilmService, добавляем аннотацию @Service в интерфейсе FilmService:

также в контроллере меняем autuwired на FilmService, а у FilmServiceImpl добавим аннотацию @Service:
   @Autowired
    private FilmService filmService;


@Service
public interface FilmService{
    void addFilm(Film film);
    void updateFilm(Film film);

    void deleteFilm(int id);

    ArrayList<Film> getFilms();
}


ublic class FilmServiceImpl implements FilmService {

    private static int id = 4;

    public String getHello() {
        return "HELLO";
    }

    public FilmServiceImpl() {
        System.out.println("WE CREATED FILMSERVICE!");
    }

    public ArrayList<Film> getFilms() {
        return DBManager.getFilms();
    }

    public void addFilm(Film film) {
        var films = getFilms();
        film.setId(id);
        id++;
        films.add(film);
    }

    public void updateFilm(Film film) {
        for(Film f: getFilms()){
            if(f.getId()==film.getId()){
                f.setTitle(film.getTitle());
                f.setDescription(film.getDescription());
                f.setRating(film.getRating());
            }
        }
    }

    public void deleteFilm(int id) {
        DBManager.deleteFilm(id);

    }
}


9. Показать пример с альтернативным сервисом Impl, который реализует методы по своему

10. @Qualifier - когда говорим какую реализацию использовать, прописать надо как в контроллере, так и в самом классе Impl
    Важно создавать от FilmService, а не от реализации

    @Autowired
    @Qualifier("second")
    private FilmService filmService;

11. Пример с аннотацией @Component:


@Component
public class WelcomeClass {

    @EventListener(ApplicationContextEvent.class)
   public void sayHello(){
        System.out.println("Hello Bitlab!");
    }
}